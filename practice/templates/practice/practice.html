{% extends "base.html" %}
{% block title %}Practice | Wrong-Answer Packets{% endblock %}

{% block content %}
<h1 class="text-3xl font-semibold mb-6 text-white drop-shadow">
  Practice <span id="subjectLabel" class="text-gray-300 text-lg"></span>
</h1>

<style>
  /* Make MathJax inline unless display */
  #qCard mjx-container { line-height: 1.6; }
  #qCard mjx-container[display="true"] { display:block !important; margin:.5rem 0 !important; }
  #qCard mjx-container:not([display="true"]) { display:inline !important; margin:0 !important; }
  #qCard mjx-container { vertical-align: baseline; }

  /* Dark text in the white card */
  #qCard, #qCard * { color:#0f172a; }

  /* Embedded PDFs compiled by the server */
  .latex-pdf { width:100%; height:240px; border:0; display:block; }
  .latex-pdf.choice { height:76px; } /* smaller for answers */

  /* Pretty choice buttons */
  .choice-btn{
    width:100%;
    text-align:left;
    padding:.75rem 1rem;
    border:1px solid #e5e7eb;             /* gray-200 */
    border-radius:.75rem;                  /* rounded-xl */
    background:rgba(255,255,255,.9);
    transition:transform .18s ease, box-shadow .18s ease, background .18s ease;
  }
  .choice-btn:hover{
    transform:translateY(-2px);
    box-shadow:0 8px 18px rgba(2,6,23,.08);
    background:#fff;
  }
  .choice-key{ font-weight:600; margin-right:.5rem; }
</style>

<div id="qCard" class="bg-white border border-gray-200 rounded-2xl shadow-sm p-6 hidden">
  <div id="stem" class="text-lg mb-4 whitespace-normal leading-7"></div>
  <div id="choices" class="space-y-2"></div>
  <div id="feedback" class="mt-4 font-semibold"></div>

  <div class="mt-6 flex items-center gap-3">
    <button id="nextBtn"
      class="inline-flex items-center justify-center px-4 py-2 rounded-xl
             border border-gray-200 bg-white/90 text-ink
             transition duration-200 ease-out transform
             hover:-translate-y-0.5 hover:shadow-md hover:bg-white
             focus:outline-none focus:ring-2 focus:ring-blue-500/30">
      Next ▶
    </button>

    <a href="/dashboard/"
       class="inline-flex items-center justify-center px-4 py-2 rounded-xl bg-blue-600 text-white hover:bg-blue-700 transition">
      Back to Dashboard
    </a>
  </div>
</div>

<div id="status" class="mt-4 text-white/80"></div>
{% endblock %}

{% block scripts %}
<script>
  const $ = (sel) => document.querySelector(sel);
  let attemptId = null;
  let currentQ  = null;
  let qOffset   = 0;   // which question to fetch next
  let qTotal    = 0;   // total questions for the current tag
  let renderToken = 0; // cancels stale async writes

  // --- CSRF ---
  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
  }
  const csrftoken = getCookie('csrftoken') || '';

  // === helpers ===============================================================
  const HEAVY_ENV = '(tikzpicture|tabular|array|align\\*?|tcolorbox|axis)';
  const HEAVY_RE  = new RegExp('\\\\begin\\{'+HEAVY_ENV+'\\}[\\s\\S]*?\\\\end\\{\\1\\}');

  function extractFirstHeavyBlock(s){
    const m = s.match(HEAVY_RE);
    if(!m) return null;
    return { before: s.slice(0, m.index), block: m[0], after: s.slice(m.index + m[0].length) };
  }

  function stripDocBody(s){
    if(!s) return '';
    const m = s.match(/\\begin\{document\}([\s\S]*?)\\end\{document\}/);
    return m ? m[1] : s;
  }

  function cleanBefore(s){
    if(!s) return '';
    if (/\\documentclass|\\usepackage|\\geometry|\\begin\{document\}/.test(s)) return '';
    return s;
  }
  function cleanAfter(s){
    if(!s) return '';
    return s.replace(/\\end\{center\}/g,'')
            .replace(/\\bigskip/g,'')
            .replace(/%[=\-]{3,}.*/g,'');
  }

  function escapeHTML(x){ return (x||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // NEW: make LaTeX lists render as HTML lists
  function maskLatexLists(s){
    return (s||'')
      .replace(/\\begin\{itemize\}/g,   '[[UL_OPEN]]')
      .replace(/\\end\{itemize\}/g,     '[[UL_CLOSE]]')
      .replace(/\\begin\{enumerate\}/g, '[[OL_OPEN]]')
      .replace(/\\end\{enumerate\}/g,   '[[OL_CLOSE]]')
      .replace(/^\s*\\item\s+/gm,       '[[LI]]');
  }
  function unmaskLists(h){
    return (h||'')
      .replace(/\[\[UL_OPEN\]\]/g,  '<ul class="list-disc ml-6">')
      .replace(/\[\[UL_CLOSE\]\]/g, '</ul>')
      .replace(/\[\[OL_OPEN\]\]/g,  '<ol class="list-decimal ml-6">')
      .replace(/\[\[OL_CLOSE\]\]/g, '</ol>')
      .replace(/\[\[LI\]\]/g,       '<li>');
  }

  // Collapse cases where inline math sits on its own line:
  //   "\n $C$ \n"  → " $C$ "
  //   "\n \(C\) \n" → " \(C\) "
  function squishSoloInlineMath(s){
    if(!s) return s;
    // $...$
    s = s.replace(/\n\s*\$([^\$\n]{1,64})\$\s*\n/g, ' $$1$ ');
    // \(...\)
    s = s.replace(/\n\s*\\\(([^\)\n]{1,64})\\\)\s*\n/g, ' \\($1\\) ');
    return s;
  }

  // Convert inline $...$ → \(...\); preserve display $$...$$ as \[...\]
  function convertInlineDollarMath(s){
    if(!s) return s;
    const displays = [];
    // stash $$...$$ blocks
    s = s.replace(/\$\$([\s\S]*?)\$\$/g, (_, c) => {
      const i = displays.push(c) - 1;
      return `[[MJXDISPLAY${i}]]`;
    });
    // convert single-dollar pairs to \(...\)
    s = s.replace(/(^|[^$])\$([^\n$]+?)\$(?!\$)/g, (m, pre, c) => `${pre}\\(${c}\\)`);
    // restore display as \[...\]
    s = s.replace(/\[\[MJXDISPLAY(\d+)\]\]/g, (_, i) => `\\[${displays[+i]}\\]`);
    return s;
  }

  function proseToHTML(s){
    s = squishSoloInlineMath(s);   // <-- add this line
    // (the rest unchanged)
    s = maskLatexLists(s);
    let h = escapeHTML(s || '');
    h = h.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
         .replace(/\\textbf\{([^}]*)\}/g, '<strong>$1</strong>')
         .replace(/\\emph\{([^}]*)\}/g, '<em>$1</em>')
         .replace(/\\textit\{([^}]*)\}/g, '<em>$1</em>')
         .replace(/\n{2,}/g, '<br><br>')
         .replace(/\n/g, ' ');
    return unmaskLists(h).trim();
  }

  function normalizeTex(s){
    if(!s) return '';
    return s.replace(/\\\\\s*/g,' ')
            .replace(/\s*\n\s*/g,' ')
            .replace(/\s{2,}/g,' ')
            .trim();
  }

  // Wrap bare math for MathJax (don’t touch text that’s already wrapped)
  function wrapInlineMathIfNeeded(s){
    if (!s) return s;
    const alreadyWrapped =
      /\$[^$]+\$/.test(s) || /\\\([^)]+\\\)/.test(s) || /\\begin\{(align|equation|gather)\}/.test(s);
    if (alreadyWrapped) return s;
    const looksMath = /\\[a-zA-Z]+|[_^]|\\sqrt|\\frac|\\cdot|\\times|\\sum|\\int/.test(s);
    if (!looksMath) return s;
    return `\\(${s.replace(/%/g, '\\%')}\\)`; // escape % to avoid TeX comments
  }

  async function fetchPdfBlobUrl(tex){
    const res = await fetch('/practice/tex/pdf/', {
      method: 'POST',
      headers: { 'Content-Type':'application/json', 'X-CSRFToken': csrftoken },
      body: JSON.stringify({ tex })
    });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!res.ok || !ct.includes('application/pdf')){
      const msg = await res.text();
      throw new Error(`TeX compile failed ${res.status}: ${msg}`);
    }
    const blob = await res.blob();
    return URL.createObjectURL(blob);
  }

  // ---- MathJax: manual typeset (deterministic) ------------------------------
  async function ensureMathJaxReady() {
    if (window.MathJax?.typesetPromise) return;
    await new Promise(resolve => {
      const deadline = Date.now() + 8000;
      (function poll(){
        if (window.MathJax?.typesetPromise || Date.now() > deadline) return resolve();
        setTimeout(poll, 25);
      })();
    });
  }
  async function typeset(target = document.querySelector('#qCard')){
    await ensureMathJaxReady();
    if (window.MathJax?.typesetPromise && target) {
      await MathJax.typesetPromise([target]);
    }
  }

  // ---- API ------------------------------------------------------------------
  async function api(url, opts={}){
    const o = Object.assign({ headers:{} }, opts);
    if (!o.headers['Content-Type'] && o.body) o.headers['Content-Type']='application/json';
    if (opts.method === 'POST') o.headers['X-CSRFToken'] = csrftoken;
    const r = await fetch(url, o);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }

  // ---- Flow -----------------------------------------------------------------
  async function startPractice(){
    try{
      const data = await api('/api/attempts/', {
        method:'POST',
        body: JSON.stringify({ assignment_title:'Practice' })
      });
      attemptId = data.attempt_id;
      await loadQuestion();
    }catch(e){
      $('#status').textContent = `Failed to start: ${e.message}`;
    }
  }

  async function loadQuestion(){
    const token = ++renderToken;            // token for this render
    $('#stem').innerHTML = '';              // clear old content immediately
    $('#choices').innerHTML = '';
    $('#feedback').textContent = '';

    $('#qCard')?.classList.remove('hidden');
    $('#qCard').style.display='block';

    try{
      const tag = new URLSearchParams(location.search).get('tag') || '';
      const url = `/api/questions/?limit=1&offset=${qOffset}&ordering=id` +
                  (tag ? `&tag=${encodeURIComponent(tag)}` : '');
      const qRes = await api(url);
      if (token !== renderToken) return;

      if (!qRes.count || !qRes.questions?.length) {
        $('#stem').innerHTML = 'No questions found.';
        $('#choices').innerHTML = '';
        $('#feedback').textContent = '';
        await typeset();
        return;
      }

      currentQ = qRes.questions[0];
      qTotal   = qRes.count || qTotal;
      qOffset  = (qOffset + 1) % Math.max(qTotal, 1);

      // ---- STEM (heavy block → PDF) -----------------------------------------
      const rawStem  = currentQ.stem_md || '';
      const body     = stripDocBody(rawStem);
      const parts    = extractFirstHeavyBlock(body);

      if(parts){
        const beforeHTML = proseToHTML(normalizeTex(cleanBefore(parts.before)));
        const afterHTML  = proseToHTML(normalizeTex(cleanAfter(parts.after)));
        const pdfUrl     = await fetchPdfBlobUrl(parts.block);
        if (token !== renderToken) return;
        $('#stem').innerHTML =
          `${beforeHTML}<object class="latex-pdf" data="${pdfUrl}" type="application/pdf"></object>${afterHTML}`;
      }else{
        if (token !== renderToken) return;
        $('#stem').innerHTML = proseToHTML(convertInlineDollarMath(normalizeTex(body)));
      }
      if (token !== renderToken) return;
      await typeset($('#stem'));
      if (token !== renderToken) return;

      // ---- CHOICES (fixed A–E order) ---------------------------------------
      const choicesDiv = $('#choices'); choicesDiv.innerHTML = '';
      const choices = currentQ.choices || {};

      const preferred = ['A','B','C','D','E'];
      let entries = preferred.filter(k => Object.prototype.hasOwnProperty.call(choices, k))
                             .map(k => [k, choices[k]]);
      if (entries.length === 0) {
        entries = Object.entries(choices).sort((a,b) => a[0].localeCompare(b[0]));
      }

      if (token !== renderToken) return;
      for (const [key,label] of entries){
        const cbody  = stripDocBody(label || '');
        const cparts = extractFirstHeavyBlock(cbody);

        const btn = document.createElement('button');
        btn.className = 'choice-btn';

        if(cparts){
          const before = proseToHTML(normalizeTex(cleanBefore(cparts.before)));
          const after  = proseToHTML(normalizeTex(cleanAfter(cparts.after)));
          const url    = await fetchPdfBlobUrl(cparts.block);
          if (token !== renderToken) return;
          btn.innerHTML =
            `<span class="choice-key">${key})</span>${before}` +
            `<object class="latex-pdf choice" data="${url}" type="application/pdf"></object>` +
            `${after}`;
        } else {
          const rawText = convertInlineDollarMath(normalizeTex(cbody));
          const maybeMath = wrapInlineMathIfNeeded(rawText);

          const keySpan  = document.createElement('span');
          keySpan.className = 'choice-key';
          keySpan.textContent = `${key}) `;

          const txtSpan  = document.createElement('span');
          txtSpan.className = 'choice-text';

          const isMath =
            /\$[^$]+\$/.test(rawText) ||
            /\\\([^)]+\\\)/.test(rawText) ||
            maybeMath.startsWith('\\(');

          if (isMath) {
            txtSpan.textContent = maybeMath;      // raw TeX -> MathJax
          } else {
            txtSpan.innerHTML   = proseToHTML(rawText); // prose -> HTML
          }

          btn.replaceChildren(keySpan, txtSpan);
        }

        btn.onclick = () => submitAnswer(key);
        choicesDiv.appendChild(btn);
      }

      if (token !== renderToken) return;
      await typeset(choicesDiv);
      if (token !== renderToken) return;

      $('#feedback').textContent = '';
      $('#status').textContent   = '';
    }catch(e){
      console.error(e);
      if (token !== renderToken) return;
      $('#status').textContent = `Failed to load question: ${e.message}`;
      $('#stem').innerHTML = '';
      $('#choices').innerHTML = '';
      $('#feedback').textContent = '';
    }
  }

  async function submitAnswer(choiceKey){
    if(!attemptId || !currentQ) return;
    try{
      const res = await api(`/api/attempts/${attemptId}/items/`, {
        method:'POST',
        body: JSON.stringify({ question_id: currentQ.id, answer:{ choice: choiceKey } })
      });
      const ok = !!res.is_correct;
      $('#feedback').textContent = ok ? '✅ Correct' : '❌ Incorrect';
      $('#feedback').className   = ok ? 'ok' : 'err';
    }catch(e){
      $('#feedback').textContent = `Submit failed: ${e.message}`;
      $('#feedback').className   = 'err';
    }
  }
  document.getElementById('nextBtn')?.addEventListener('click', loadQuestion);
  document.addEventListener('DOMContentLoaded', startPractice);
</script>

<!-- MathJax (manual typeset via startup.typeset=false) -->
<script>
  window.MathJax = {
    tex: { inlineMath: [['$','$'], ['\\(','\\)']] },
    svg: { fontCache: 'global' },
    startup: { typeset: false }
  };
</script>
<script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
{% endblock %}














