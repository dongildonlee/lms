{% extends "base.html" %}
{% block title %}Practice | Wrong-Answer Packets{% endblock %}

{% block content %}
<h1 class="text-3xl font-semibold mb-6 text-white drop-shadow">
  Practice <span id="subjectLabel" class="text-gray-300 text-lg"></span>
</h1>

<style>
  /* Make MathJax inline unless display */
  #qCard mjx-container { line-height: 1.6; }
  #qCard mjx-container[display="true"] { display:block; margin:.5rem 0; }
  #qCard mjx-container:not([display="true"]) { display:inline; }

  /* Dark text in the white card */
  #qCard, #qCard * { color:#0f172a; }

  /* Embedded PDFs compiled by the server */
  .latex-pdf { width:100%; height:240px; border:0; display:block; }
  .latex-pdf.choice { height:76px; } /* smaller for answers */
</style>

<div id="qCard" class="bg-white border border-gray-200 rounded-2xl shadow-sm p-6 hidden">
  <div id="stem" class="text-lg mb-4 whitespace-normal leading-7"></div>
  <div id="choices" class="space-y-2"></div>
  <div id="feedback" class="mt-4 font-semibold"></div>

  <div class="mt-6 flex items-center gap-3">
    <button id="nextBtn"
      class="inline-flex items-center justify-center px-4 py-2 rounded-xl
             border border-gray-200 bg-white/90 text-ink
             transition duration-200 ease-out transform
             hover:-translate-y-0.5 hover:shadow-md hover:bg-white
             focus:outline-none focus:ring-2 focus:ring-blue-500/30">
      Next ▶
    </button>

    <a href="/dashboard/"
       class="inline-flex items-center justify-center px-4 py-2 rounded-xl bg-blue-600 text-white hover:bg-blue-700 transition">
      Back to Dashboard
    </a>
  </div>
</div>

<div id="status" class="mt-4 text-white/80"></div>
{% endblock %}

{% block scripts %}
<script>
  const $ = (sel) => document.querySelector(sel);
  let attemptId = null;
  let currentQ = null;

  // CSRF helper
  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
  }
  const csrftoken = getCookie('csrftoken') || '';

  // --- LaTeX helpers --------------------------------------------------------

  // Only use the server PDF compiler for HEAVY LaTeX (tikz, tabular, align envs, etc.)
  function needsFullLaTeX(s) {
    if (!s) return false;
    return /\\begin\{(tikzpicture|tabular|array|align\*?|tcolorbox|axis)\}|\\includegraphics/.test(s);
  }

  // If the string contains a full LaTeX document, keep only the body
  function stripDocBody(s) {
    if (!s) return '';
    const m = s.match(/\\begin\{document\}([\s\S]*?)\\end\{document\}/);
    return m ? m[1] : s;
  }

  // Light normalizer for MathJax display
  function normalizeTex(s) {
    if (!s) return '';
    return s
      .replace(/\\\\\s*/g, ' ')   // TeX \\ linebreaks -> space
      .replace(/\s*\n\s*/g, ' ')  // collapse newlines
      .replace(/\s{2,}/g, ' ')    // collapse runs of spaces
      .trim();
  }

  // POST TeX to the server compiler and return a blob URL for the resulting PDF.
  async function fetchPdfBlobUrl(tex) {
    const res = await fetch('/practice/tex/pdf/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrftoken },
      body: JSON.stringify({ tex })
    });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if (!res.ok || !ct.includes('application/pdf')) {
      const msg = await res.text();
      throw new Error(`TeX compile failed (${res.status}): ${msg}`);
    }
    const blob = await res.blob();
    return URL.createObjectURL(blob);
  }

  // MathJax typeset (only the card)
  async function typeset() {
    const card = $('#qCard');
    if (window.MathJax && MathJax.typesetPromise && card) {
      await MathJax.typesetPromise([card]);
    }
  }

  // --- API helper -----------------------------------------------------------
  async function api(url, opts = {}) {
    const o = Object.assign({ headers: {} }, opts);
    if (!o.headers['Content-Type'] && o.body) o.headers['Content-Type'] = 'application/json';
    if (opts.method === 'POST') o.headers['X-CSRFToken'] = csrftoken;
    const res = await fetch(url, o);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  // --- Flow -----------------------------------------------------------------

  async function startPractice() {
    try {
      const data = await api('/api/attempts/', {
        method: 'POST',
        body: JSON.stringify({ assignment_title: 'Practice' })
      });
      attemptId = data.attempt_id;
      $('#status').textContent = `Attempt #${attemptId} started.`;
      await loadQuestion();
    } catch (err) {
      $('#status').textContent = `Failed to start: ${err.message}`;
    }
  }

  async function loadQuestion() {
    $('#qCard').style.display = 'block';
    try {
      const tag = $('#tag')?.value?.trim() || '';
      const url = `/api/questions/?limit=1${tag ? `&tag=${encodeURIComponent(tag)}` : ''}`;
      const qRes = await api(url);

      if (!qRes.count) {
        $('#stem').innerHTML = 'No questions found. Add some in <code>/admin</code> or clear the tag.';
        $('#choices').innerHTML = '';
        $('#feedback').textContent = '';
        $('#status').textContent = 'No questions found.';
        await typeset();
        return;
      }

      currentQ = qRes.questions[0];
      const rawStem = currentQ.stem_md || '';
      const stemBody = stripDocBody(rawStem);

      // ---- STEM ----
      if (needsFullLaTeX(stemBody)) {
        const pdfUrl = await fetchPdfBlobUrl(stemBody);
        $('#stem').innerHTML = `<object class="latex-pdf" data="${pdfUrl}" type="application/pdf"></object>`;
      } else {
        $('#stem').innerHTML = normalizeTex(stemBody);
      }

      // ---- CHOICES ----
      const choicesDiv = $('#choices');
      choicesDiv.innerHTML = '';
      const choices = currentQ.choices || {};
      for (const [key, label] of Object.entries(choices)) {
        const raw = label || '';
        const body = stripDocBody(raw);
        const btn = document.createElement('button');
        btn.className = 'choice';

        if (needsFullLaTeX(body)) {
          const pdfUrl = await fetchPdfBlobUrl(body);
          btn.innerHTML = `<span style="margin-right:8px;font-weight:600">${key})</span>
                           <object class="latex-pdf choice" data="${pdfUrl}" type="application/pdf"></object>`;
        } else {
          btn.innerHTML = `${key}) ${normalizeTex(body)}`;
        }

        btn.onclick = () => submitAnswer(key);
        choicesDiv.appendChild(btn);
      }

      $('#feedback').textContent = '';
      $('#status').textContent = '';
      await typeset();
    } catch (err) {
      console.error('loadQuestion error:', err);
      $('#status').textContent = `Failed to load question: ${err.message}`;
      $('#stem').innerHTML = '';
      $('#choices').innerHTML = '';
      $('#feedback').textContent = '';
    }
  }

  async function submitAnswer(choiceKey) {
    if (!attemptId || !currentQ) return;
    try {
      const res = await api(`/api/attempts/${attemptId}/items/`, {
        method: 'POST',
        body: JSON.stringify({ question_id: currentQ.id, answer: { choice: choiceKey } })
      });
      $('#feedback').textContent = res.is_correct ? '✅ Correct' : '❌ Incorrect';
      $('#feedback').className = res.is_correct ? 'ok' : 'err';
    } catch (err) {
      $('#feedback').textContent = `Submit failed: ${err.message}`;
      $('#feedback').className = 'err';
    }
  }

  $('#startBtn')?.addEventListener('click', startPractice);
  $('#nextBtn')?.addEventListener('click', loadQuestion);
</script>


<!-- MathJax for light inline TeX -->
<script>
  window.MathJax = { tex:{ inlineMath:[['$','$'],['\\(','\\)']] }, svg:{ fontCache:'global' } };
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
{% endblock %}





