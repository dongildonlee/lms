{% extends "base.html" %}
{% block title %}Practice | Wrong-Answer Packets{% endblock %}

{% block content %}
<h1 class="text-3xl font-semibold mb-6 text-white drop-shadow">Practice</h1>

<style>
  /* Keep MathJax inline unless explicitly display */
  #qCard mjx-container { line-height: 1.6; }
  #qCard mjx-container[display="true"] { display:block; margin:.5rem 0; }
  #qCard mjx-container:not([display="true"]) { display:inline; }

  /* Card text color */
  #qCard, #qCard * { color:#0f172a; }

  /* PDF objects: width 100%, height set by JS; white bg masks viewer chrome */
  .latex-pdf { width:100%; display:block; background:#fff; border:0; }
  .choice-btn {
    display:block; width:100%;
    text-align:left; padding:14px 16px; border-radius:12px;
    border:1px solid #e5e7eb; background:#fff;
    transition:transform .15s ease, box-shadow .15s ease, background .15s ease;
  }
  .choice-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(15,23,42,.08); background:#fff; }
  .choice-key { font-weight:600; margin-right:8px; }
</style>

<div id="qCard" class="bg-white border border-gray-200 rounded-2xl shadow-sm p-6 hidden">
  <div id="stem" class="text-lg mb-5 whitespace-normal leading-7"></div>
  <div id="choices" class="space-y-2"></div>
  <div id="feedback" class="mt-4 font-semibold"></div>

  <div class="mt-6 flex items-center gap-3">
    <button id="nextBtn"
      class="inline-flex items-center justify-center px-4 py-2 rounded-xl
             border border-gray-200 bg-white/90 text-ink
             transition duration-200 ease-out transform
             hover:-translate-y-0.5 hover:shadow-md hover:bg-white
             focus:outline-none focus:ring-2 focus:ring-blue-500/30">
      Next ▶
    </button>

    <a href="/dashboard/"
       class="inline-flex items-center justify-center px-4 py-2 rounded-xl bg-blue-600 text-white hover:bg-blue-700 transition">
      Back to Dashboard
    </a>
  </div>
</div>

<div id="status" class="mt-4 text-white/80"></div>
{% endblock %}

{% block scripts %}
<script>
  const $ = sel => document.querySelector(sel);
  let attemptId = null, currentQ = null;

  // CSRF
  function getCookie(n){ const v=`; ${document.cookie}`; const p=v.split(`; ${n}=`); if(p.length===2) return p.pop().split(';').shift(); }
  const csrftoken = getCookie('csrftoken') || '';

  // Detect “heavy” LaTeX envs
  const HEAVY_ENV = '(tikzpicture|tabular|array|align\\*?|tcolorbox|axis)';
  const HEAVY_RE  = new RegExp('\\\\begin\\{'+HEAVY_ENV+'\\}[\\s\\S]*?\\\\end\\{\\1\\}');
  function extractFirstHeavyBlock(s){
    const m=s.match(HEAVY_RE); if(!m) return null;
    return { before:s.slice(0,m.index), block:m[0], after:s.slice(m.index+m[0].length) };
  }

  // Keep body if a full document slipped in
  function stripDocBody(s){
    if(!s) return '';
    const m = s.match(/\\begin\{document\}([\s\S]*?)\\end\{document\}/);
    return m ? m[1] : s;
  }

  // Light prose formatting: **bold**, \textit{}, \emph{}
  function escapeHTML(x){ return (x||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function proseToHTML(s){
    let h = escapeHTML(s||'');
    h = h.replace(/\*\*([^*]+)\*\*/g,'<strong>$1</strong>');
    h = h.replace(/\\textit\{([^}]*)\}/g,'<em>$1</em>');
    h = h.replace(/\\emph\{([^}]*)\}/g,'<em>$1</em>');
    h = h.replace(/\n{2,}/g,'<br><br>').replace(/\n/g,' ');
    return h.trim();
  }

  // MathJax-safe normalization for light cases
  function normalizeTex(s){
    return (s||'').replace(/\\\\\s*/g,' ').replace(/\s*\n\s*/g,' ').replace(/\s{2,}/g,' ').trim();
  }

  // POST TeX -> PDF blob URL
  async function fetchPdfBlobUrl(tex){
    const res = await fetch('/practice/tex/pdf/', {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'X-CSRFToken': csrftoken },
      body: JSON.stringify({ tex })
    });
    const ct=(res.headers.get('content-type')||'').toLowerCase();
    if(!res.ok || !ct.includes('application/pdf')){
      const msg=await res.text();
      throw new Error(`TeX compile failed ${res.status}: ${msg}`);
    }
    const blob=await res.blob();
    return URL.createObjectURL(blob);
  }

  // Insert a PDF <object> and size it from width using an aspect ratio
  function injectPdfObject(container, url, ratio){
    container.innerHTML = '';
    const obj = document.createElement('object');
    obj.className = 'latex-pdf';
    obj.type = 'application/pdf';
    obj.data = url;
    container.appendChild(obj);
    // Size after it’s in the layout
    requestAnimationFrame(()=> {
      const w = obj.clientWidth || container.clientWidth || 600;
      const h = Math.max(120, Math.round(w / ratio)); // ratio = width/height
      obj.style.height = h + 'px';
    });
  }

  async function typeset(){
    if(window.MathJax?.typesetPromise) await MathJax.typesetPromise([$('#qCard')]);
  }

  async function api(url, opts={}){
    const o=Object.assign({headers:{}},opts);
    if(!o.headers['Content-Type'] && o.body) o.headers['Content-Type']='application/json';
    if(opts.method==='POST') o.headers['X-CSRFToken']=csrftoken;
    const r=await fetch(url,o);
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }

  async function startPractice(){
    try{
      const data = await api('/api/attempts/', { method:'POST', body: JSON.stringify({ assignment_title:'Practice' }) });
      attemptId=data.attempt_id;
      await loadQuestion();
    }catch(e){ $('#status').textContent=`Failed to start: ${e.message}`; }
  }

  async function loadQuestion(){
    $('#qCard').classList.remove('hidden');
    $('#qCard').style.display='block';

    try{
      const tag = new URLSearchParams(location.search).get('tag') || '';
      const qRes = await api(`/api/questions/?limit=1${tag ? `&tag=${encodeURIComponent(tag)}` : ''}`);
      if(!qRes.count){
        $('#stem').innerHTML='No questions found.';
        $('#choices').innerHTML='';
        $('#feedback').textContent='';
        await typeset(); return;
      }

      currentQ = qRes.questions[0];
      const body = stripDocBody(currentQ.stem_md || '');
      const parts = extractFirstHeavyBlock(body);

      // STEM
      if(parts){
        const before = proseToHTML(normalizeTex(parts.before));
        const after  = proseToHTML(normalizeTex(parts.after));
        const url    = await fetchPdfBlobUrl(parts.block);
        $('#stem').innerHTML = `${before}<div id="stemPdfHolder"></div>${after}`;
        injectPdfObject($('#stemPdfHolder'), url, /* width/height */ 4/3);
      }else{
        $('#stem').innerHTML = proseToHTML(normalizeTex(body));
      }

      // CHOICES
      const choicesDiv=$('#choices'); choicesDiv.innerHTML='';
      const choices=currentQ.choices || {};
      for(const [key,label] of Object.entries(choices)){
        const cbody  = stripDocBody(label || '');
        const cparts = extractFirstHeavyBlock(cbody);

        const btn=document.createElement('button');
        btn.className='choice-btn';
        btn.type='button';

        if(cparts){
          const before=proseToHTML(normalizeTex(cparts.before));
          const after =proseToHTML(normalizeTex(cparts.after));
          btn.innerHTML = `<span class="choice-key">${key})</span>${before}<div class="choicePdfHolder"></div>${after}`;
          const url = await fetchPdfBlobUrl(cparts.block);
          // Use a wide ratio for compact answers; tweak if needed
          setTimeout(()=> injectPdfObject(btn.querySelector('.choicePdfHolder'), url, 6/1), 0);
        }else{
          btn.innerHTML = `<span class="choice-key">${key})</span>${proseToHTML(normalizeTex(cbody))}`;
        }

        btn.onclick=()=>submitAnswer(key);
        choicesDiv.appendChild(btn);
      }

      $('#feedback').textContent='';
      $('#status').textContent='';
      await typeset();
    }catch(e){
      console.error(e);
      $('#status').textContent=`Failed to load question: ${e.message}`;
      $('#stem').innerHTML=''; $('#choices').innerHTML=''; $('#feedback').textContent='';
    }
  }

  async function submitAnswer(choiceKey){
    if(!attemptId || !currentQ) return;
    try{
      const res = await api(`/api/attempts/${attemptId}/items/`, {
        method:'POST', body: JSON.stringify({ question_id: currentQ.id, answer:{ choice: choiceKey } })
      });
      const ok=!!res.is_correct;
      $('#feedback').textContent = ok ? '✅ Correct' : '❌ Incorrect';
      $('#feedback').className   = ok ? 'ok' : 'err';
    }catch(e){
      $('#feedback').textContent=`Submit failed: ${e.message}`;
      $('#feedback').className='err';
    }
  }

  document.addEventListener('DOMContentLoaded', startPractice);
</script>

<!-- MathJax (light inline math) -->
<script>
  window.MathJax = { tex:{ inlineMath:[['$','$'],['\\(','\\)']] }, svg:{ fontCache:'global' } };
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
{% endblock %}








